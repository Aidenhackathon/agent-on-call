# LangGraph Multi-Agent Triage Flow

## Overview

The Agent-on-Call system uses a **LangGraph-based multi-agent workflow** to automatically triage support tickets. The workflow consists of 5 sequential agents that analyze tickets and determine priority, assignment, generate rationale explanations, and create customer replies.

## Flow Diagram

```
┌─────────────────┐
│  Ticket Created │
└────────┬────────┘
         │
         ▼
┌─────────────────────┐
│  1. ContextAgent    │ ◄─── Fetches ticket, comments, attachments
│  (fetch_context)    │      Builds compact context for downstream agents
└──────────┬──────────┘
           │
           ▼
┌─────────────────────┐
│  2. PriorityAgent   │ ◄─── Heuristics + Gemini AI
│(determine_priority) │      Determines: P0, P1, P2, or P3
└──────────┬──────────┘      Returns: priority, confidence
           │
           ▼
┌─────────────────────┐
│  3. AssigneeAgent   │ ◄─── Skill matching + Gemini AI
│   (assign_user)     │      Scores teams based on context, selects best match
└──────────┬──────────┘      Returns: assignee_user_id
           │
           ▼
┌─────────────────────┐
│  4. RationaleAgent  │ ◄─── Gemini AI
│ (generate_rationale)│      Generates rationale for priority and assignee
└──────────┬──────────┘      Returns: priority_rationale, assignee_rationale
           │
           ▼
┌─────────────────────┐
│   5. ReplyAgent     │ ◄─── Gemini AI
│  (generate_reply)   │      Generates customer reply draft (≤120 words)
└──────────┬──────────┘      Returns: reply text
           │
           ▼
┌─────────────────────┐
│   6. PersistNode    │ ◄─── MongoDB Updates
│   (save_results)    │      Updates ticket, logs activity
└──────────┬──────────┘
           │
           ▼
        ┌─────┐
        │ END │
        └─────┘
```

## Detailed Agent Descriptions

### 1. ContextAgent (`fetch_context`)

**Purpose**: Gathers all relevant ticket information into a compact context object.

**Location**: `backend/triage/agents/context_agent.py`

**Input State**:
```python
{
    "ticket": {...},  # Full ticket document from MongoDB
    "context": None,
    ...
}
```

**Process**:
1. Extracts ticket title, description, tags, product_area
2. Fetches related comments (last 10)
3. Fetches related attachments (last 5)
4. Builds compact context dictionary

**Output State**:
```python
{
    "context": {
        "title": str,
        "body": str,  # Description text
        "tags": List[str],
        "product_area": str,
        "comments": List[dict],
        "attachments": List[dict]
    },
    ...
}
```

**Error Handling**: Sets `state["error"]` if ticket is missing or invalid.

---

### 2. PriorityAgent (`determine_priority`)

**Purpose**: Determines ticket priority using heuristics and Gemini AI validation.

**Location**: `backend/triage/agents/priority_agent.py`

**Input State**:
```python
{
    "context": {...},  # From ContextAgent
    "priority": None,
    ...
}
```

**Process**:
1. **Heuristic Analysis**: Scans title, body, and tags for priority keywords
   - **P0 Keywords**: "payment failed", "site down", "outage", "security breach", "data loss", "critical error", "production down"
   - **P1 Keywords**: "api error", "broken", "not working", "urgent", "major bug", "customer facing"
   - **P2 Keywords**: "minor bug", "issue", "problem", "billing question", "feature not working"
   - **P3**: Default for everything else

2. **Gemini Validation** (if API key available):
   - Sends heuristic suggestion to Gemini
   - Gemini confirms or adjusts priority
   - Returns refined priority with confidence score

3. **Fallback**: Uses heuristic result if Gemini fails

**Output State**:
```python
{
    "priority": {
        "priority": "P0|P1|P2|P3",
        "confidence": float  # 0.0 to 1.0
    },
    ...
}
```

**Note**: Rationale is no longer generated by PriorityAgent. It's generated separately by RationaleAgent.

**Model**: `gemini-2.0-flash-exp`

---

### 3. AssigneeAgent (`assign_user`)

**Purpose**: Assigns ticket to the best available team based on skills and context matching.

**Location**: `backend/triage/agents/assignee_agent.py`

**Input State**:
```python
{
    "context": {...},  # From ContextAgent
    "priority": {...},  # From PriorityAgent
    "assignee": None,
    ...
}
```

**Process**:
1. **Fetch Teams**: Retrieves all teams from MongoDB `users` collection
2. **Score Teams**: For each team, calculates:
   - **Skill Score**: Matches team skills against ticket content (title, body, tags, product_area)
     - Each matching skill: +10 points
   - **Final Score**: Based purely on skill match (no workload consideration)

3. **Sort Teams**: Orders teams by score (highest first)

4. **Gemini Selection** (if API key available):
   - Sends top 5 candidates to Gemini
   - Gemini selects best team considering skills and context relevance
   - Validates selected team ID exists

5. **Fallback**: Picks top-scored team if Gemini fails

**Output State**:
```python
{
    "assignee": {
        "assignee_user_id": str  # Team ID (e.g., "backend_team")
    },
    ...
}
```

**Note**: Rationale is no longer generated by AssigneeAgent. It's generated separately by RationaleAgent.

**Model**: `gemini-2.0-flash-exp`

**Example Scoring**:
```
Team: Backend Team
Skills: ["python", "fastapi", "mongodb", "api"]
Ticket: "API endpoint returning 500 error"
Matches: "api" → +10 points
Final Score: 10
```

---

### 4. RationaleAgent (`generate_rationale`)

**Purpose**: Generates clear, professional rationale explanations for priority and assignee decisions.

**Location**: `backend/triage/agents/rationale_agent.py`

**Input State**:
```python
{
    "context": {...},      # From ContextAgent
    "priority": {...},     # From PriorityAgent (priority, confidence)
    "assignee": {...},     # From AssigneeAgent (assignee_user_id)
    "rationale": None,
    ...
}
```

**Process**:
1. **Validates Inputs**: Ensures context, priority, and assignee information are available
2. **Fetches Team Info**: Retrieves team name and skills from MongoDB for rationale generation
3. **Gemini Generation** (if API key available):
   - Sends ticket context, priority decision, and assignee information to Gemini
   - Prompts for two separate rationales:
     - **Priority Rationale**: Explains why the priority level was assigned
     - **Assignee Rationale**: Explains why the team was assigned
   - Each rationale should be 50-80 words, specific, and reference ticket details
4. **Fallback**: Uses template-based rationale generation if Gemini fails

**Output State**:
```python
{
    "rationale": {
        "priority_rationale": str,   # Explanation for priority assignment
        "assignee_rationale": str    # Explanation for team assignment
    },
    ...
}
```

**Model**: `gemini-2.0-flash-exp`

**Example Output**:
```python
{
    "priority_rationale": "Critical priority assigned due to system outage affecting customer access. Immediate attention required to minimize customer impact and prevent escalation.",
    "assignee_rationale": "Assigned to DevOps Team because the ticket requires expertise in kubernetes, docker, infrastructure. This team has the necessary skills to effectively resolve this issue."
}
```

---

### 5. ReplyAgent (`generate_reply`)

**Purpose**: Generates a professional customer reply draft (max 120 words).

**Location**: `backend/triage/agents/reply_agent.py`

**Input State**:
```python
{
    "context": {...},  # From ContextAgent
    "priority": {...},  # From PriorityAgent
    "assignee": {...},  # From AssigneeAgent
    "reply": None,
    ...
}
```

**Process**:
1. **Gemini Generation** (if API key available):
   - Sends ticket title, body, and priority to Gemini
   - Prompts for professional, empathetic reply
   - **Strict requirement**: ≤120 words
   - Sets expectations based on priority:
     - **P0**: Immediate escalation, updates every 30 min
     - **P1**: High priority, update in 2-4 hours
     - **P2**: Standard review, response in 24-48 hours
     - **P3**: Normal queue, response in 2-3 business days

2. **Word Limit Enforcement**: Truncates to 120 words if exceeded

3. **Fallback**: Uses template-based mock reply if Gemini fails

**Output State**:
```python
{
    "reply": str,  # Customer reply draft text (≤120 words)
    ...
}
```

**Model**: `gemini-2.0-flash-exp`

**Example Reply (P0)**:
```
Hello,

Thank you for reporting this critical issue. We have immediately 
escalated this to our engineering team and they are actively 
investigating. We will provide updates every 30 minutes until 
resolved. We sincerely apologize for the inconvenience.

Best regards,
Support Team
```

---

### 6. PersistNode (`save_results`)

**Purpose**: Persists all triage results to MongoDB.

**Location**: `backend/triage/agents/persist_node.py`

**Input State**:
```python
{
    "ticket": {...},      # Original ticket
    "priority": {...},    # From PriorityAgent
    "assignee": {...},    # From AssigneeAgent
    "rationale": {...},   # From RationaleAgent
    "reply": str,         # From ReplyAgent
    ...
}
```

**Process**:
1. **Update Ticket**:
   - Sets `priority`, `assignee_user_id`, `status` = "triaged"
   - Updates `assignee` (team name for display)
   - Combines `priority_rationale` and `assignee_rationale` into `ai_rationale`
   - Sets `ai_reply_draft`, `ai_confidence`
   - Updates `updated_at` timestamp

2. **Insert Triage Result**:
   - Creates document in `triage_results` collection
   - Stores priority, assignee, `priority_rationale`, `assignee_rationale`, reply_draft

3. **Log Activity**:
   - Inserts into `activity_logs` collection
   - Event type: `triage_run`
   - Payload: priority, assignee, confidence

**Output State**:
```python
{
    "error": None,  # Cleared on success
    ...
}
```

**Error Handling**: Sets `state["error"]` and logs failure to `activity_logs` if any step fails.

---

## State Schema

The workflow uses a `TriageState` TypedDict:

```python
class TriageState(TypedDict, total=False):
    ticket: Optional[dict]      # Original ticket from MongoDB
    context: Optional[dict]     # Compact context from ContextAgent
    priority: Optional[dict]    # Priority info from PriorityAgent (priority, confidence)
    assignee: Optional[dict]    # Assignee info from AssigneeAgent (assignee_user_id)
    rationale: Optional[dict]   # Rationale from RationaleAgent (priority_rationale, assignee_rationale)
    reply: Optional[str]        # Reply draft from ReplyAgent
    error: Optional[str]        # Error message if any step fails
```

## Execution Flow

### Entry Point
```python
POST /tickets/{ticket_id}/triage
```

### Workflow Execution
```python
# 1. Create graph
graph = create_triage_graph()

# 2. Initialize state
initial_state = {
    "ticket": ticket,  # From MongoDB
    "context": None,
    "priority": None,
    "assignee": None,
    "rationale": None,
    "reply": None,
    "error": None
}

# 3. Execute workflow
final_state = await graph.ainvoke(initial_state)

# 4. Check for errors
if final_state.get("error"):
    raise Exception(final_state["error"])

# 5. Return results (already persisted by PersistNode)
```

## Error Handling

Each agent handles errors gracefully:
- **ContextAgent**: Sets `state["error"]` if ticket is invalid
- **PriorityAgent**: Falls back to heuristics if Gemini fails
- **AssigneeAgent**: Falls back to top-scored team if Gemini fails
- **RationaleAgent**: Falls back to template rationale if Gemini fails
- **ReplyAgent**: Falls back to template reply if Gemini fails
- **PersistNode**: Logs errors to `activity_logs` collection

If any agent sets `state["error"]`, the workflow continues but the error is checked at the end and returned to the API caller.

## Mock Mode

If `USE_MOCK_AI=true` or `GEMINI_API_KEY` is not set:
- **PriorityAgent**: Uses heuristics only
- **AssigneeAgent**: Selects top-scored team (no Gemini)
- **RationaleAgent**: Uses template-based rationale generation
- **ReplyAgent**: Uses template-based replies

This allows the system to work without API keys for testing.

## Database Collections Used

1. **`tickets`**: Main ticket documents
2. **`users`**: Team definitions (skills only - no workload tracking)
3. **`triage_results`**: Historical triage results
4. **`activity_logs`**: Activity events (triage runs, failures)
5. **`comments`**: Ticket comments (fetched by ContextAgent)
6. **`attachments`**: Ticket attachments (fetched by ContextAgent)

## Configuration

### Environment Variables
- `GEMINI_API_KEY`: Google Gemini API key (optional)
- `USE_MOCK_AI`: Set to "true" to disable AI and use fallbacks
- `MONGODB_URL`: MongoDB connection string

### Model Configuration
All agents use `gemini-2.0-flash-exp` with:
- Temperature: 0.2 (low for consistent results)
- API: LangChain Google Generative AI

## Example Execution

**Input Ticket**:
```json
{
  "title": "API endpoint returning 500 error",
  "description": "The /api/users endpoint is returning 500 errors for all requests.",
  "category": "Technical"
}
```

**Workflow Steps**:

1. **ContextAgent**: Extracts title, description, no comments/attachments
2. **PriorityAgent**: 
   - Heuristic: "api error" → P1
   - Gemini confirms P1 (confidence: 0.92)
3. **AssigneeAgent**:
   - Scores teams: Backend Team (score: 10), DevOps Team (score: 0), ...
   - Gemini selects Backend Team based on skill match
4. **RationaleAgent**:
   - Generates priority rationale: "High priority assigned due to major functionality issues affecting users..."
   - Generates assignee rationale: "Assigned to Backend Team because the ticket requires expertise in python, fastapi, api..."
5. **ReplyAgent**:
   - Generates: "Hello, Thank you for reporting this. We've flagged this as high priority..."
6. **PersistNode**:
   - Updates ticket: priority=P1, assignee_user_id=backend_team, status=triaged
   - Combines rationales into ai_rationale field
   - Logs activity

**Result**: Ticket is triaged, assigned, and ready for team response.

---

## Architecture Benefits

1. **Modularity**: Each agent has a single responsibility
2. **Extensibility**: Easy to add new agents or modify existing ones
3. **Error Resilience**: Fallbacks at each step
4. **Observability**: All steps logged to activity_logs
5. **Testability**: Can test each agent independently
6. **Scalability**: LangGraph handles state management and execution

---

## Future Enhancements

- **Conditional Edges**: Route based on priority (P0 might skip some steps)
- **Parallel Execution**: Run PriorityAgent and AssigneeAgent in parallel
- **Feedback Loop**: Learn from manual overrides
- **Multi-language Support**: Generate replies in customer's language
- **Sentiment Analysis**: Adjust priority based on customer sentiment

